### NestJS_Entity

---

## 🤔 Entity 무엇인가?

이런 식으로 테이블을 생성해줍니다. 하지만 TypeORM을 사용할떄는
데이터베이스 테이블로 변환 되는 Class이기 때문에 위에 처럼하

### 📋 엔티티 생성 소스 코드

**@Entity()**

- Entity () 데코레이터 클래스는 Board 클래스가 엔티티임을 나타내는
  데 사용됩니다. CREATE TABLE board 부분입니다.

**@PrimaryGeneratedColumn()**

- PrimaryGeneratedColumn () 데코레이터 클래스는 id 열이 Board 엔터
  티의 기본 키 열임을 나타내는 데 사용됩니다.

**@Column()**

- Column () 데코레이터 클래스는 Board 엔터티의 title 및 description과
  같은 다른 열을 나타내는 데 사용됩니다.

- Entity 클래스 Board가 생성되었습니다.
- TypeORM은 데이터베이스의 Board 엔터티에 해당하는 테이블을 자동으로 생성하고 board로 이름을 지정합니다.

---

## 🧩 엔티티의 역할과 특징

- 엔티티는 데이터베이스 테이블과 1:1로 매핑되는 클래스입니다. 클래스의 각 필드는 컬럼으로 매핑됩니다.
- 비즈니스 규칙의 핵심 모델이므로, 의미 있는 속성 이름과 타입을 갖도록 설계해야 합니다.
- TypeORM 설정(`synchronize`)에 따라 엔티티 정의가 실제 테이블 생성/변경에 자동 반영될 수 있습니다.

## 🔧 자주 사용하는 컬럼 옵션

- **nullable**: 컬럼이 NULL을 허용할지 여부
- **unique**: 컬럼 값의 고유성 제약
- **length / precision / scale**: 문자열 길이, 숫자 정밀도/스케일
- **default**: 값이 없을 때 사용할 기본값
- **name**: 데이터베이스의 실제 컬럼명(코드 네이밍과 분리하고 싶을 때)

## 🔑 기본 키 생성 전략 개념

- `@PrimaryGeneratedColumn('increment')`: 숫자 자동 증가(대부분의 RDB 기본)
- `@PrimaryGeneratedColumn('uuid')`: 전역 고유 식별자 필요 시(분산/샤딩 환경 유용)

## 🔗 관계 매핑 크게 보기

- `@ManyToOne` / `@OneToMany`: 다대일 ↔ 일대다(가장 흔함)
- `@OneToOne`: 1:1 관계(FK 소유 측을 명확히)
- `@ManyToMany`: 다대다(조인 테이블 생성). 실무에선 중간 엔티티로 풀어내는 설계가 더 명확한 경우가 많음
- 지연 로딩(Lazy) vs 즉시 로딩(Eager) 선택은 성능과 쿼리 복잡도에 영향

## 🕒 공통 감사 컬럼과 수명주기

- `createdAt`, `updatedAt` 같은 시간 컬럼으로 생성/수정 시각을 관리
- 논리 삭제가 필요하면 `deletedAt`(소프트 삭제) 컬럼을 두고 실제 삭제 대신 필터링 처리
- DB 기본값(`DEFAULT now()`) 또는 애플리케이션 레벨 훅을 적절히 조합

## 🧱 인덱스와 성능

- 조회가 잦은 컬럼에는 인덱스를 고려하되, 과도한 인덱스는 쓰기 성능을 저하시킴
- 고유성 제약(unique)과 인덱스 전략을 함께 설계해 무결성과 성능을 균형 있게 유지

## 🧭 네이밍 전략과 스키마 관리

- 코드(camelCase)와 DB(snake_case) 간 네이밍 전략을 초기에 통일
- 개발 단계에서는 `synchronize`로 빠르게 진행 가능하나, 운영 환경에서는 마이그레이션으로 명시적 변경 권장

## 🧪 유효성 검증의 책임 분리

- DTO에서 입력값 유효성 검증을 1차 수행하고, 엔티티는 스키마 제약으로 무결성을 보완
- 상태 전이 같은 도메인 규칙은 서비스 레이어 중심으로 관리하되, 의도 드러내기 위해 엔티티 메서드 활용 가능

## ✅ 점검 체크리스트

- 컬럼의 NULL 허용/기본값이 비즈니스 규칙과 일치하는가?
- 필요한 인덱스/고유성 제약을 빠뜨리지 않았는가?
- 관계 정의가 실제 조회/쓰기 패턴과 성능 요구사항에 맞는가?
- 운영 배포는 마이그레이션으로 스키마를 관리하는가?

---
